package handlers

import (
	"net/http"

	"injection-tracker/internal/database"
	"injection-tracker/internal/middleware"
	"injection-tracker/internal/models"
	"injection-tracker/internal/repository"
	"injection-tracker/internal/web"
)

// getBasePageData returns common data for all authenticated pages
func getBasePageData(r *http.Request, csrf *middleware.CSRFProtection) map[string]interface{} {
	userID := middleware.GetUserID(r.Context())

	data := map[string]interface{}{
		"IsAuthenticated": true,
		"UserID":          userID,
	}

	// Generate CSRF token if CSRF protection is available
	if csrf != nil {
		data["CSRFToken"] = csrf.GenerateToken()
	}

	return data
}

// HandleHome redirects to login if not authenticated, otherwise to dashboard
func HandleHome(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if user is authenticated via cookie
		cookie, err := r.Cookie("auth_token")
		if err != nil || cookie.Value == "" {
			// Not authenticated, show login page
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		// Authenticated, redirect to dashboard
		http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
	}
}

// HandleLoginPage renders the login page
func HandleLoginPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title":           "Login",
		"IsAuthenticated": false,
		"CSRFToken":       "", // Will be generated by HTMX
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	// Render login.html - the Render function will execute base.html with the login content block
	if err := web.Render(w, "login.html", data); err != nil {
		http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
		return
	}
}

// HandleRegisterPage renders the registration page
func HandleRegisterPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Register",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "register.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleForgotPasswordPage renders the forgot password page
func HandleForgotPasswordPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Forgot Password",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "forgot-password.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleSetupPage renders the first-run setup page
func HandleSetupPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if setup is already complete
		var count int
		if err := db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count); err == nil && count > 0 {
			// Setup already complete - redirect to login
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		data := map[string]interface{}{
			"Title": "First-Run Setup",
			"IsAuthenticated": false,
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "setup.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleDashboard renders the dashboard page
func HandleDashboard(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Dashboard"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "dashboard.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInjectionsPage renders the injections history page
func HandleInjectionsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Injections - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "injections.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSymptomsPage renders the symptoms page
func HandleSymptomsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptoms - Injection Tracker"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleMedicationsPage renders the medications page
func HandleMedicationsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Medications - Injection Tracker"
		data["Action"] = r.URL.Query().Get("action")

		// Fetch active medications
		medicationRepo := repository.NewMedicationRepository(db)
		activeMeds, err := medicationRepo.ListActive()
		if err == nil && len(activeMeds) > 0 {
			// Check if each medication was taken today
			for _, med := range activeMeds {
				// Query if there's a log entry for today
				var count int
				db.QueryRow(`
					SELECT COUNT(*) FROM medication_logs
					WHERE medication_id = ?
					AND DATE(timestamp) = DATE('now')
					AND taken = 1
				`, med.ID).Scan(&count)
				med.TakenToday = count > 0
			}
			data["ActiveMedications"] = activeMeds
		}

		// Fetch inactive medications
		allMeds, err := medicationRepo.List()
		if err == nil {
			inactiveMeds := []*models.Medication{}
			for _, med := range allMeds {
				if !med.IsActive {
					inactiveMeds = append(inactiveMeds, med)
				}
			}
			if len(inactiveMeds) > 0 {
				data["InactiveMedications"] = inactiveMeds
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "medications.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryPage renders the inventory page
func HandleInventoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Inventory - Injection Tracker"

		// Fetch inventory items
		rows, err := db.Query(`
			SELECT id, item_type, quantity, unit, expiration_date,
				lot_number, low_stock_threshold, notes, created_at, updated_at
			FROM inventory_items
			ORDER BY item_type
		`)
		if err == nil {
			defer rows.Close()

			items := []map[string]interface{}{}
			totalItems := 0
			lowStockCount := 0
			expiringSoonCount := 0

			for rows.Next() {
				var item models.InventoryItem
				err := rows.Scan(
					&item.ID,
					&item.ItemType,
					&item.Quantity,
					&item.Unit,
					&item.ExpirationDate,
					&item.LotNumber,
					&item.LowStockThreshold,
					&item.Notes,
					&item.CreatedAt,
					&item.UpdatedAt,
				)
				if err == nil {
					totalItems++

					// Check if low stock
					lowStock := false
					if item.LowStockThreshold.Valid && item.Quantity <= item.LowStockThreshold.Float64 {
						lowStock = true
						lowStockCount++
					}

					// Build display item
					displayItem := map[string]interface{}{
						"ID":                item.ID,
						"ItemType":          item.ItemType,
						"DisplayName":       getInventoryDisplayName(item.ItemType),
						"Icon":              getInventoryIcon(item.ItemType),
						"Quantity":          item.Quantity,
						"Unit":              item.Unit,
						"LowStock":          lowStock,
						"LowStockThreshold": item.LowStockThreshold.Float64,
					}

					if item.ExpirationDate.Valid {
						displayItem["ExpirationDate"] = item.ExpirationDate.Time
						displayItem["FormattedExpiration"] = item.ExpirationDate.Time.Format("Jan 2, 2006")
					}
					if item.LotNumber.Valid {
						displayItem["LotNumber"] = item.LotNumber.String
					}

					items = append(items, displayItem)
				}
			}

			data["InventoryItems"] = items
			data["TotalItems"] = totalItems
			data["LowStockCount"] = lowStockCount
			data["ExpiringSoonCount"] = expiringSoonCount

			// Add default settings
			data["Settings"] = map[string]interface{}{
				"ProgesteronePerInjection": 1.0,
				"AutoDeduct":               true,
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// getInventoryDisplayName returns a friendly display name for inventory items
func getInventoryDisplayName(itemType string) string {
	names := map[string]string{
		"progesterone":     "Progesterone",
		"draw_needle":      "Draw Needles",
		"injection_needle": "Injection Needles",
		"syringe":          "Syringes",
		"swab":             "Alcohol Swabs",
		"gauze":            "Gauze Pads",
	}
	if name, ok := names[itemType]; ok {
		return name
	}
	return itemType
}

// getInventoryIcon returns an icon/emoji for inventory items
func getInventoryIcon(itemType string) string {
	icons := map[string]string{
		"progesterone":     "ðŸ’‰",
		"draw_needle":      "ðŸ”¹",
		"injection_needle": "ðŸ”¸",
		"syringe":          "ðŸ’Š",
		"swab":             "ðŸ§¼",
		"gauze":            "ðŸ©¹",
	}
	if icon, ok := icons[itemType]; ok {
		return icon
	}
	return "ðŸ“¦"
}

// HandleCoursesPage renders the courses page
func HandleCoursesPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Courses - Injection Tracker"
		data["Action"] = r.URL.Query().Get("action")

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		// Get past courses
		courses, err := courseRepo.List()
		if err == nil {
			pastCourses := []*models.Course{}
			for _, course := range courses {
				if !course.IsActive {
					pastCourses = append(pastCourses, course)
				}
			}
			if len(pastCourses) > 0 {
				data["PastCourses"] = pastCourses
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "courses.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleCalendarPage renders the calendar page
func HandleCalendarPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Calendar - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "calendar.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleReportsPage renders the reports page
func HandleReportsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Reports - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "reports.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSettingsPage renders the settings page
func HandleSettingsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Settings"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "settings.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewCoursePage redirects to courses page with action parameter to open modal
func HandleNewCoursePage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/courses?action=new", http.StatusSeeOther)
	}
}

// HandleLogSymptomPage renders the log symptom page
func HandleLogSymptomPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to symptoms page
		http.Redirect(w, r, "/symptoms?action=new", http.StatusSeeOther)
	}
}

// HandleSymptomsHistoryPage renders the symptoms history page
func HandleSymptomsHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptom History - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms-history.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewMedicationPage redirects to medications page with modal
func HandleNewMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// HandleLogMedicationPage renders the log medication page
func HandleLogMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to medications page
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// HandleGetRecentActivity returns recent activity HTML for dashboard
func HandleGetRecentActivity(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID := middleware.GetUserID(r.Context())
		_ = userID // TODO: Use this to fetch user-specific activity

		// For now, return empty state
		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte(`
			<div style="text-align: center; padding: 2rem; color: var(--pico-muted-color);">
				<p>No recent activity yet.</p>
				<small>Start by creating a course and logging your first injection!</small>
			</div>
		`))
	}
}