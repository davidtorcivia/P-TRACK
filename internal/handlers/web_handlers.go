package handlers

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"injection-tracker/internal/database"
	"injection-tracker/internal/middleware"
	"injection-tracker/internal/models"
	"injection-tracker/internal/repository"
	"injection-tracker/internal/web"

	"github.com/go-chi/chi/v5"
)

// getBasePageData returns common data for all authenticated pages
func getBasePageData(r *http.Request, csrf *middleware.CSRFProtection) map[string]interface{} {
	userID := middleware.GetUserID(r.Context())

	data := map[string]interface{}{
		"IsAuthenticated": true,
		"UserID":          userID,
	}

	// Generate CSRF token if CSRF protection is available
	if csrf != nil {
		data["CSRFToken"] = csrf.GenerateToken()
	}

	return data
}

// HandleHome redirects to login if not authenticated, otherwise to dashboard
func HandleHome(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if user is authenticated via cookie
		cookie, err := r.Cookie("auth_token")
		if err != nil || cookie.Value == "" {
			// Not authenticated, show login page
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		// Authenticated, redirect to dashboard
		http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
	}
}

// HandleLoginPage renders the login page
func HandleLoginPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title":           "Login",
		"IsAuthenticated": false,
		"CSRFToken":       "", // Will be generated by HTMX
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	// Render login.html - the Render function will execute base.html with the login content block
	if err := web.Render(w, "login.html", data); err != nil {
		http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
		return
	}
}

// HandleRegisterPage renders the registration page
func HandleRegisterPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Register",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "register.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleForgotPasswordPage renders the forgot password page
func HandleForgotPasswordPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Forgot Password",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "forgot-password.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleSetupPage renders the first-run setup page
func HandleSetupPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if setup is already complete
		var count int
		if err := db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count); err == nil && count > 0 {
			// Setup already complete - redirect to login
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		data := map[string]interface{}{
			"Title": "First-Run Setup",
			"IsAuthenticated": false,
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "setup.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleDashboard renders the dashboard page
func HandleDashboard(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Dashboard"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			activeData := map[string]interface{}{
				"ID":        activeCourse.ID,
				"Name":      activeCourse.Name,
				"StartDate": activeCourse.StartDate.Format("Jan 2, 2006"),
			}
			if activeCourse.ExpectedEndDate.Valid {
				activeData["ExpectedEndDate"] = activeCourse.ExpectedEndDate.Time.Format("Jan 2, 2006")
			}
			if activeCourse.Notes.Valid {
				activeData["Notes"] = activeCourse.Notes.String
			}
			data["ActiveCourse"] = activeData

			// Get last injection for this course
			var lastInjection struct {
				ID        int64
				Timestamp time.Time
				Side      string
				TimeAgo   string
			}
			var lastSide string
			err := db.QueryRow(`
				SELECT id, timestamp, side
				FROM injections
				WHERE course_id = ?
				ORDER BY timestamp DESC
				LIMIT 1
			`, activeCourse.ID).Scan(&lastInjection.ID, &lastInjection.Timestamp, &lastInjection.Side)
			if err == nil {
				lastInjection.TimeAgo = formatTimeAgoWeb(lastInjection.Timestamp)
				lastSide = lastInjection.Side
				data["LastInjection"] = &lastInjection
			}

			// Get basic statistics for the active course
			stats := map[string]interface{}{}

			// Total injections
			var totalInjections int
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ?", activeCourse.ID).Scan(&totalInjections)
			stats["TotalInjections"] = totalInjections

			// Side counts
			var leftCount, rightCount int
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ? AND side = 'left'", activeCourse.ID).Scan(&leftCount)
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ? AND side = 'right'", activeCourse.ID).Scan(&rightCount)
			stats["LeftCount"] = leftCount
			stats["RightCount"] = rightCount

			// Next injection site (opposite of last injection)
			nextSide := "Left" // Default recommendation
			if lastSide == "left" {
				nextSide = "Right"
			} else if lastSide == "right" {
				nextSide = "Left"
			}
			stats["NextInjectionSite"] = nextSide
			stats["LastInjectionSide"] = strings.Title(lastSide)
			if lastSide == "" {
				stats["LastInjectionSide"] = "None"
			}

			// Course duration
			stats["CourseDays"] = activeCourse.DaysActive()

			data["Stats"] = stats

			// Get low stock items
			lowStockItems := []map[string]interface{}{}
			rows, err := db.Query(`
				SELECT item_type, quantity, unit, expiration_date, low_stock_threshold
				FROM inventory_items
				WHERE low_stock_threshold IS NOT NULL
				AND quantity <= low_stock_threshold
				ORDER BY item_type
			`)
			if err == nil {
				defer rows.Close()
				for rows.Next() {
					var item struct {
						ItemType          string
						Quantity          float64
						Unit              string
						ExpirationDate    sql.NullTime
						LowStockThreshold float64
					}
					if err := rows.Scan(&item.ItemType, &item.Quantity, &item.Unit, &item.ExpirationDate, &item.LowStockThreshold); err == nil {
						lowStockItems = append(lowStockItems, map[string]interface{}{
							"ItemType":       item.ItemType,
							"Quantity":       item.Quantity,
							"Unit":           item.Unit,
							"ExpirationDate": item.ExpirationDate,
						})
					}
				}
			}
			data["LowStockItems"] = lowStockItems
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "dashboard.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInjectionsPage renders the injections history page
func HandleInjectionsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Injections"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = map[string]interface{}{
				"ID":   activeCourse.ID,
				"Name": activeCourse.Name,
			}

			// Get injections for this course
			rows, err := db.Query(`
				SELECT id, timestamp, side, pain_level, notes
				FROM injections
				WHERE course_id = ?
				ORDER BY timestamp DESC
				LIMIT 50
			`, activeCourse.ID)
			if err == nil {
				defer rows.Close()
				injections := []map[string]interface{}{}
				for rows.Next() {
					var id int64
					var timestamp time.Time
					var side string
					var painLevel sql.NullInt64
					var notes sql.NullString

					if err := rows.Scan(&id, &timestamp, &side, &painLevel, &notes); err == nil {
						injections = append(injections, map[string]interface{}{
							"ID":        id,
							"Date":      timestamp.Format("Jan 2, 2006"),
							"Time":      timestamp.Format("3:04 PM"),
							"Side":      strings.Title(side),
							"PainLevel": painLevel.Int64,
							"Notes":     notes.String,
						})
					}
				}
				data["Injections"] = injections
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "injections.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleSymptomsPage renders the symptoms page
func HandleSymptomsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptoms"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = map[string]interface{}{
				"ID":   activeCourse.ID,
				"Name": activeCourse.Name,
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleMedicationsPage renders the medications page
func HandleMedicationsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Medications - Injection Tracker"
		data["Action"] = r.URL.Query().Get("action")

		// Fetch active medications
		medicationRepo := repository.NewMedicationRepository(db)
		activeMeds, err := medicationRepo.ListActive()
		if err == nil && len(activeMeds) > 0 {
			// Check if each medication was taken today
			for _, med := range activeMeds {
				// Query if there's a log entry for today
				var count int
				db.QueryRow(`
					SELECT COUNT(*) FROM medication_logs
					WHERE medication_id = ?
					AND DATE(timestamp) = DATE('now')
					AND taken = 1
				`, med.ID).Scan(&count)
				med.TakenToday = count > 0
			}
			data["ActiveMedications"] = activeMeds
		}

		// Fetch inactive medications
		allMeds, err := medicationRepo.List()
		if err == nil {
			inactiveMeds := []*models.Medication{}
			for _, med := range allMeds {
				if !med.IsActive {
					inactiveMeds = append(inactiveMeds, med)
				}
			}
			if len(inactiveMeds) > 0 {
				data["InactiveMedications"] = inactiveMeds
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "medications.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryPage renders the inventory page
func HandleInventoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Inventory - Injection Tracker"

		// Fetch inventory items
		rows, err := db.Query(`
			SELECT id, item_type, quantity, unit, expiration_date,
				lot_number, low_stock_threshold, notes, created_at, updated_at
			FROM inventory_items
			ORDER BY item_type
		`)
		if err == nil {
			defer rows.Close()

			items := []map[string]interface{}{}
			totalItems := 0
			lowStockCount := 0
			expiringSoonCount := 0

			for rows.Next() {
				var item models.InventoryItem
				err := rows.Scan(
					&item.ID,
					&item.ItemType,
					&item.Quantity,
					&item.Unit,
					&item.ExpirationDate,
					&item.LotNumber,
					&item.LowStockThreshold,
					&item.Notes,
					&item.CreatedAt,
					&item.UpdatedAt,
				)
				if err == nil {
					totalItems++

					// Check if low stock
					lowStock := false
					if item.LowStockThreshold.Valid && item.Quantity <= item.LowStockThreshold.Float64 {
						lowStock = true
						lowStockCount++
					}

					// Build display item
					displayItem := map[string]interface{}{
						"ID":                item.ID,
						"ItemType":          item.ItemType,
						"DisplayName":       getInventoryDisplayName(item.ItemType),
						"Icon":              getInventoryIcon(item.ItemType),
						"Quantity":          item.Quantity,
						"Unit":              item.Unit,
						"LowStock":          lowStock,
						"LowStockThreshold": item.LowStockThreshold.Float64,
					}

					if item.ExpirationDate.Valid {
						displayItem["ExpirationDate"] = item.ExpirationDate.Time
						displayItem["FormattedExpiration"] = item.ExpirationDate.Time.Format("Jan 2, 2006")
					}
					if item.LotNumber.Valid {
						displayItem["LotNumber"] = item.LotNumber.String
					}

					items = append(items, displayItem)
				}
			}

			data["InventoryItems"] = items
			data["TotalItems"] = totalItems
			data["LowStockCount"] = lowStockCount
			data["ExpiringSoonCount"] = expiringSoonCount

			// Add default settings
			data["Settings"] = map[string]interface{}{
				"ProgesteronePerInjection": 1.0,
				"AutoDeduct":               true,
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// getInventoryDisplayName returns a friendly display name for inventory items
func getInventoryDisplayName(itemType string) string {
	names := map[string]string{
		"progesterone":     "Progesterone",
		"draw_needle":      "Draw Needles",
		"injection_needle": "Injection Needles",
		"syringe":          "Syringes",
		"swab":             "Alcohol Swabs",
		"gauze":            "Gauze Pads",
	}
	if name, ok := names[itemType]; ok {
		return name
	}
	return itemType
}

// getInventoryIcon returns an icon/emoji for inventory items
func getInventoryIcon(itemType string) string {
	icons := map[string]string{
		"progesterone":     "",
		"draw_needle":      "",
		"injection_needle": "",
		"syringe":          "",
		"swab":             "",
		"gauze":            "",
	}
	if icon, ok := icons[itemType]; ok {
		return icon
	}
	return ""
}

// HandleCoursesPage renders the courses page
func HandleCoursesPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Courses"

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			activeData := map[string]interface{}{
				"ID":            activeCourse.ID,
				"Name":          activeCourse.Name,
				"StartDate":     activeCourse.StartDate.Format("Jan 2, 2006"),
				"StartDateISO":  activeCourse.StartDate.Format("2006-01-02"),
				"Notes":         "",
			}
			if activeCourse.ExpectedEndDate.Valid {
				activeData["ExpectedEndDate"] = activeCourse.ExpectedEndDate.Time.Format("Jan 2, 2006")
				activeData["ExpectedEndDateISO"] = activeCourse.ExpectedEndDate.Time.Format("2006-01-02")
			}
			if activeCourse.Notes.Valid {
				activeData["Notes"] = activeCourse.Notes.String
			}
			data["ActiveCourse"] = activeData
		}

		// Get past courses
		courses, err := courseRepo.List()
		if err == nil {
			pastCourses := []map[string]interface{}{}
			for _, course := range courses {
				if !course.IsActive {
					pastData := map[string]interface{}{
						"ID":           course.ID,
						"Name":         course.Name,
						"StartDate":    course.StartDate.Format("Jan 2, 2006"),
						"StartDateISO": course.StartDate.Format("2006-01-02"),
					}
					if course.ActualEndDate.Valid {
						pastData["ActualEndDate"] = course.ActualEndDate.Time.Format("Jan 2, 2006")
						pastData["ActualEndDateISO"] = course.ActualEndDate.Time.Format("2006-01-02")
					}
					if course.ExpectedEndDate.Valid {
						pastData["ExpectedEndDate"] = course.ExpectedEndDate.Time.Format("Jan 2, 2006")
						pastData["ExpectedEndDateISO"] = course.ExpectedEndDate.Time.Format("2006-01-02")
					}
					if course.Notes.Valid {
						pastData["Notes"] = course.Notes.String
					}
					pastCourses = append(pastCourses, pastData)
				}
			}
			if len(pastCourses) > 0 {
				data["PastCourses"] = pastCourses
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "courses.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleCalendarPage renders the calendar page
func HandleCalendarPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Calendar - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "calendar.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleReportsPage renders the reports page
func HandleReportsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Reports - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "reports.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSettingsPage renders the settings page
func HandleSettingsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Settings"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "settings.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewCoursePage redirects to courses page with action parameter to open modal
func HandleNewCoursePage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/courses?action=new", http.StatusSeeOther)
	}
}

// HandleLogSymptomPage renders the log symptom page
func HandleLogSymptomPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to symptoms page
		http.Redirect(w, r, "/symptoms?action=new", http.StatusSeeOther)
	}
}

// HandleEditSymptomPage renders the edit symptom page
func HandleEditSymptomPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Edit Symptom - Injection Tracker"

		// Get symptom ID from URL
		idStr := chi.URLParam(r, "id")
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err != nil {
			http.Error(w, "Invalid symptom log ID", http.StatusBadRequest)
			return
		}

		// Get symptom log
		symptomRepo := repository.NewSymptomRepository(db)
		symptom, err := symptomRepo.GetByID(id)
		if err != nil {
			http.Error(w, "Symptom log not found", http.StatusNotFound)
			return
		}

		// Get active course for the template
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		data["Symptom"] = symptom

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptom_edit.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSymptomsHistoryPage renders the symptoms history page
func HandleSymptomsHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptom History - Injection Tracker"

		// Get active course for consistency with other pages
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse()
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms-history.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewMedicationPage redirects to medications page with modal
func HandleNewMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// HandleLogMedicationPage renders the log medication page
func HandleLogMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to medications page
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// formatTimeAgoWeb returns a human-readable time ago string
func formatTimeAgoWeb(t time.Time) string {
	duration := time.Since(t)
	if duration.Hours() < 1 {
		minutes := int(duration.Minutes())
		if minutes == 1 {
			return "1 minute ago"
		}
		return fmt.Sprintf("%d minutes ago", minutes)
	} else if duration.Hours() < 24 {
		hours := int(duration.Hours())
		if hours == 1 {
			return "1 hour ago"
		}
		return fmt.Sprintf("%d hours ago", hours)
	} else {
		days := int(duration.Hours() / 24)
		if days == 1 {
			return "1 day ago"
		}
		return fmt.Sprintf("%d days ago", days)
	}
}

// HandleGetRecentActivity returns recent activity HTML for dashboard
func HandleGetRecentActivity(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID := middleware.GetUserID(r.Context())
		_ = userID // TODO: Use this to fetch user-specific activity

		// Get recent activity from different tables
		activities := []map[string]interface{}{}

		// Recent injections (last 5)
		rows, err := db.Query(`
			SELECT 'injection' as type, timestamp, side, pain_level, notes, id
			FROM injections
			ORDER BY timestamp DESC
			LIMIT 5
		`)
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var activity struct {
					Type       string
					Timestamp  time.Time
					Side       string
					PainLevel  sql.NullInt64
					Notes      sql.NullString
					ID         int64
				}
				if err := rows.Scan(&activity.Type, &activity.Timestamp, &activity.Side, &activity.PainLevel, &activity.Notes, &activity.ID); err == nil {
					activities = append(activities, map[string]interface{}{
						"Type":      activity.Type,
						"Side":      activity.Side,
						"PainLevel": activity.PainLevel.Int64,
						"Notes":     activity.Notes.String,
						"TimeAgo":   formatTimeAgoWeb(activity.Timestamp),
						"UserName":  "You", // TODO: Get actual username
					})
				}
			}
		}

		// Recent symptoms (last 3)
		rows, err = db.Query(`
			SELECT 'symptom' as type, timestamp, pain_level, pain_location, notes, id
			FROM symptom_logs
			ORDER BY timestamp DESC
			LIMIT 3
		`)
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var activity struct {
					Type         string
					Timestamp    time.Time
					PainLevel    sql.NullInt64
					PainLocation sql.NullString
					Notes        sql.NullString
					ID           int64
				}
				if err := rows.Scan(&activity.Type, &activity.Timestamp, &activity.PainLevel, &activity.PainLocation, &activity.Notes, &activity.ID); err == nil {
					activities = append(activities, map[string]interface{}{
						"Type":         activity.Type,
						"PainLevel":    activity.PainLevel.Int64,
						"PainLocation": activity.PainLocation.String,
						"Notes":        activity.Notes.String,
						"TimeAgo":      formatTimeAgoWeb(activity.Timestamp),
						"UserName":     "You", // TODO: Get actual username
					})
				}
			}
		}

		// Sort by timestamp (combined from different queries)
		// For now, just return injections first, then symptoms

		if len(activities) == 0 {
			w.Header().Set("Content-Type", "text/html")
			w.Write([]byte(`
				<div style="text-align: center; padding: 2rem; color: var(--pico-muted-color);">
					<p>No recent activity yet.</p>
					<small>Start by creating a course and logging your first injection!</small>
				</div>
			`))
			return
		}

		// Render recent activity template
		w.Header().Set("Content-Type", "text/html")
		html := `<ul style="list-style: none; padding: 0;">`

		for _, activity := range activities {
			html += `<li style="padding: 0.75rem 0; border-bottom: 1px solid var(--pico-muted-border-color);">
				<div style="display: flex; justify-content: space-between; align-items: center;">
					<div>
						<strong>`

			switch activity["Type"].(string) {
			case "injection":
				html += fmt.Sprintf("Injection (%s)", activity["Side"])
				if painLevel, ok := activity["PainLevel"].(int64); ok && painLevel > 0 {
					html += fmt.Sprintf(` <small>(Pain: %d/10)</small>`, painLevel)
				}
			case "symptom":
				html += "Symptom Log"
				if painLevel, ok := activity["PainLevel"].(int64); ok && painLevel > 0 {
					html += fmt.Sprintf(" (Pain: %d/10)", painLevel)
				}
				if location, ok := activity["PainLocation"].(string); ok && location != "" {
					html += fmt.Sprintf(" - %s", location)
				}
			}

			html += fmt.Sprintf(`</strong><br><small>%s â€¢ %s</small>`, activity["TimeAgo"], activity["UserName"])

			if notes, ok := activity["Notes"].(string); ok && notes != "" {
				if len(notes) > 50 {
					notes = notes[:50] + "..."
				}
				html += fmt.Sprintf("<br><small>%s</small>", notes)
			}

			html += `</div></div></li>`
		}

		html += `</ul>`
		w.Write([]byte(html))
	}
}
// HandleInventoryHistoryPage renders the full inventory history page
func HandleInventoryHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Inventory History - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory_history.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryItemHistoryPage renders the inventory history for a specific item type
func HandleInventoryItemHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		itemType := chi.URLParam(r, "itemType")
		
		// Display names for item types
		displayNames := map[string]string{
			"progesterone":      "Progesterone",
			"draw_needle":       "Draw Needles",
			"injection_needle":  "Injection Needles",
			"syringe":          "Syringes",
			"swab":             "Alcohol Swabs",
			"gauze":            "Gauze Pads",
		}
		
		displayName, ok := displayNames[itemType]
		if !ok {
			http.Error(w, "Invalid item type", http.StatusBadRequest)
			return
		}
		
		data["ItemType"] = itemType
		data["DisplayName"] = displayName
		data["Title"] = displayName + " History - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory_item_history.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}
