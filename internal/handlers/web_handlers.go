package handlers

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"injection-tracker/internal/database"
	"injection-tracker/internal/middleware"
	"injection-tracker/internal/models"
	"injection-tracker/internal/repository"
	"injection-tracker/internal/web"

	"github.com/go-chi/chi/v5"
)

// getBasePageData returns common data for all authenticated pages
func getBasePageData(r *http.Request, csrf *middleware.CSRFProtection) map[string]interface{} {
	userID := middleware.GetUserID(r.Context())
	accountID := middleware.GetAccountID(r.Context())

	data := map[string]interface{}{
		"IsAuthenticated": true,
		"AccountID":        accountID,
		"UserID":          userID,
	}

	// Generate CSRF token if CSRF protection is available
	if csrf != nil {
		data["CSRFToken"] = csrf.GenerateToken()
	}

	return data
}

// HandleHome redirects to login if not authenticated, otherwise to dashboard
func HandleHome(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if user is authenticated via cookie
		cookie, err := r.Cookie("auth_token")
		if err != nil || cookie.Value == "" {
			// Not authenticated, show login page
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		// Authenticated, redirect to dashboard
		http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
	}
}

// HandleLoginPage renders the login page
func HandleLoginPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title":           "Login",
		"IsAuthenticated": false,
		"CSRFToken":       "", // Will be generated by HTMX
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	// Render login.html - the Render function will execute base.html with the login content block
	if err := web.Render(w, "login.html", data); err != nil {
		http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
		return
	}
}

// HandleRegisterPage renders the registration page
func HandleRegisterPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Register",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "register.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleForgotPasswordPage renders the forgot password page
func HandleForgotPasswordPage(w http.ResponseWriter, r *http.Request) {
	data := map[string]interface{}{
		"Title": "Forgot Password",
		"IsAuthenticated": false,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := web.Render(w, "forgot-password.html", data); err != nil {
		http.Error(w, "Failed to render template", http.StatusInternalServerError)
		return
	}
}

// HandleSetupPage renders the first-run setup page
func HandleSetupPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Check if setup is already complete
		var count int
		if err := db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count); err == nil && count > 0 {
			// Setup already complete - redirect to login
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		data := map[string]interface{}{
			"Title": "First-Run Setup",
			"IsAuthenticated": false,
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "setup.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleDashboard renders the dashboard page
func HandleDashboard(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Dashboard"

		// Get user's timezone preference
		userID := middleware.GetUserID(r.Context())
		accountID := middleware.GetAccountID(r.Context())
		userTimezone := GetUserTimezone(db, userID)

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			activeData := map[string]interface{}{
				"ID":        activeCourse.ID,
				"Name":      activeCourse.Name,
				"StartDate": activeCourse.StartDate.Format("Jan 2, 2006"),
			}
			if activeCourse.ExpectedEndDate.Valid {
				activeData["ExpectedEndDate"] = activeCourse.ExpectedEndDate.Time.Format("Jan 2, 2006")
			}
			if activeCourse.Notes.Valid {
				activeData["Notes"] = activeCourse.Notes.String
			}
			data["ActiveCourse"] = activeData

			// Get last injection for this course
			var lastInjection struct {
				ID        int64
				Timestamp time.Time
				Side      string
				TimeAgo   string
			}
			var lastSide string
			err := db.QueryRow(`
				SELECT id, timestamp, side
				FROM injections
				WHERE course_id = ?
				ORDER BY timestamp DESC
				LIMIT 1
			`, activeCourse.ID).Scan(&lastInjection.ID, &lastInjection.Timestamp, &lastInjection.Side)
			if err == nil {
				// Convert timestamp to user's timezone
				convertedTime := ConvertToUserTZ(lastInjection.Timestamp, userTimezone)
				lastInjection.TimeAgo = formatTimeAgoWeb(convertedTime)
				lastSide = lastInjection.Side
				data["LastInjection"] = &lastInjection
			}

			// Get basic statistics for the active course
			stats := map[string]interface{}{}

			// Total injections
			var totalInjections int
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ?", activeCourse.ID).Scan(&totalInjections)
			stats["TotalInjections"] = totalInjections

			// Side counts
			var leftCount, rightCount int
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ? AND side = 'left'", activeCourse.ID).Scan(&leftCount)
			db.QueryRow("SELECT COUNT(*) FROM injections WHERE course_id = ? AND side = 'right'", activeCourse.ID).Scan(&rightCount)
			stats["LeftCount"] = leftCount
			stats["RightCount"] = rightCount

			// Next injection site (opposite of last injection)
			nextSide := "Left" // Default recommendation
			if lastSide == "left" {
				nextSide = "Right"
			} else if lastSide == "right" {
				nextSide = "Left"
			}
			stats["NextInjectionSite"] = nextSide
			stats["LastInjectionSide"] = strings.Title(lastSide)
			if lastSide == "" {
				stats["LastInjectionSide"] = "None"
			}

			// Course duration
			stats["CourseDays"] = activeCourse.DaysActive()

			data["Stats"] = stats

			// Get low stock items
			lowStockItems := []map[string]interface{}{}
			rows, err := db.Query(`
				SELECT item_type, quantity, unit, expiration_date, low_stock_threshold
				FROM inventory_items
				WHERE low_stock_threshold IS NOT NULL
				AND quantity <= low_stock_threshold
				ORDER BY item_type
			`)
			if err == nil {
				defer rows.Close()
				for rows.Next() {
					var item struct {
						ItemType          string
						Quantity          float64
						Unit              string
						ExpirationDate    sql.NullTime
						LowStockThreshold float64
					}
					if err := rows.Scan(&item.ItemType, &item.Quantity, &item.Unit, &item.ExpirationDate, &item.LowStockThreshold); err == nil {
						lowStockItems = append(lowStockItems, map[string]interface{}{
							"ItemType":       item.ItemType,
							"Quantity":       item.Quantity,
							"Unit":           item.Unit,
							"ExpirationDate": item.ExpirationDate,
						})
					}
				}
			}
			data["LowStockItems"] = lowStockItems
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "dashboard.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInjectionsPage renders the injections history page
func HandleInjectionsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Injections"

		// Get user's timezone preference
		userID := middleware.GetUserID(r.Context())
		accountID := middleware.GetAccountID(r.Context())
		userTimezone := GetUserTimezone(db, userID)

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = map[string]interface{}{
				"ID":   activeCourse.ID,
				"Name": activeCourse.Name,
			}

			// Get injections for this course
			rows, err := db.Query(`
				SELECT id, timestamp, side, pain_level, notes
				FROM injections
				WHERE course_id = ?
				ORDER BY timestamp DESC
				LIMIT 50
			`, activeCourse.ID)
			if err == nil {
				defer rows.Close()
				injections := []map[string]interface{}{}
				for rows.Next() {
					var id int64
					var timestamp time.Time
					var side string
					var painLevel sql.NullInt64
					var notes sql.NullString

					if err := rows.Scan(&id, &timestamp, &side, &painLevel, &notes); err == nil {
						// Convert timestamp to user's timezone
						convertedTime := ConvertToUserTZ(timestamp, userTimezone)
						timeStr := FormatTimeForUser(db, userID, timestamp)
						injections = append(injections, map[string]interface{}{
							"ID":        id,
							"Date":      convertedTime.Format("Jan 2, 2006"),
							"Time":      timeStr,
							"Side":      strings.Title(side),
							"SideLower": side,  // Add lowercase version for radio buttons
							"PainLevel": painLevel.Int64,
							"Notes":     notes.String,
						})
					}
				}
				data["Injections"] = injections
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "injections.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleSymptomsPage renders the symptoms page
func HandleSymptomsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptoms"
		accountID := middleware.GetAccountID(r.Context())

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = map[string]interface{}{
				"ID":   activeCourse.ID,
				"Name": activeCourse.Name,
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleMedicationsPage renders the medications page
func HandleMedicationsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Medications - Injection Tracker"
		data["Action"] = r.URL.Query().Get("action")

		accountID := middleware.GetAccountID(r.Context())
		// Fetch active medications
		medicationRepo := repository.NewMedicationRepository(db)
		activeMeds, err := medicationRepo.ListActive(accountID)
		if err == nil && len(activeMeds) > 0 {
			// Check if each medication was taken today
			for _, med := range activeMeds {
				// Query if there's a log entry for today
				var count int
				db.QueryRow(`
					SELECT COUNT(*) FROM medication_logs
					WHERE medication_id = ?
					AND DATE(timestamp) = DATE('now')
					AND taken = 1
				`, med.ID).Scan(&count)
				med.TakenToday = count > 0
			}
			data["ActiveMedications"] = activeMeds
		}

		// Fetch inactive medications
		allMeds, err := medicationRepo.List(accountID)
		if err == nil {
			inactiveMeds := []*models.Medication{}
			for _, med := range allMeds {
				if !med.IsActive {
					inactiveMeds = append(inactiveMeds, med)
				}
			}
			if len(inactiveMeds) > 0 {
				data["InactiveMedications"] = inactiveMeds
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "medications.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryPage renders the inventory page
func HandleInventoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Inventory - Injection Tracker"

		// Fetch inventory items
		rows, err := db.Query(`
			SELECT id, item_type, quantity, unit, expiration_date,
				lot_number, low_stock_threshold, notes, created_at, updated_at
			FROM inventory_items
			ORDER BY item_type
		`)
		if err == nil {
			defer rows.Close()

			items := []map[string]interface{}{}
			totalItems := 0
			lowStockCount := 0
			expiringSoonCount := 0

			for rows.Next() {
				var item models.InventoryItem
				err := rows.Scan(
					&item.ID,
					&item.ItemType,
					&item.Quantity,
					&item.Unit,
					&item.ExpirationDate,
					&item.LotNumber,
					&item.LowStockThreshold,
					&item.Notes,
					&item.CreatedAt,
					&item.UpdatedAt,
				)
				if err == nil {
					totalItems++

					// Check if low stock
					lowStock := false
					if item.LowStockThreshold.Valid && item.Quantity <= item.LowStockThreshold.Float64 {
						lowStock = true
						lowStockCount++
					}

					// Build display item
					displayItem := map[string]interface{}{
						"ID":                item.ID,
						"ItemType":          item.ItemType,
						"DisplayName":       getInventoryDisplayName(item.ItemType),
						"Icon":              getInventoryIcon(item.ItemType),
						"Quantity":          item.Quantity,
						"Unit":              item.Unit,
						"LowStock":          lowStock,
						"LowStockThreshold": item.LowStockThreshold.Float64,
					}

					if item.ExpirationDate.Valid {
						displayItem["ExpirationDate"] = item.ExpirationDate.Time
						displayItem["FormattedExpiration"] = item.ExpirationDate.Time.Format("Jan 2, 2006")

						// Check if expiring soon (within 30 days)
						daysUntilExpiration := int(time.Until(item.ExpirationDate.Time).Hours() / 24)
						if daysUntilExpiration <= 30 && daysUntilExpiration >= 0 {
							displayItem["ExpiringSoon"] = true
							expiringSoonCount++
						}
					}
					if item.LotNumber.Valid {
						displayItem["LotNumber"] = item.LotNumber.String
					}

					items = append(items, displayItem)
				}
			}

			data["InventoryItems"] = items
			data["TotalItems"] = totalItems
			data["LowStockCount"] = lowStockCount
			data["ExpiringSoonCount"] = expiringSoonCount

			// Add default settings
			data["Settings"] = map[string]interface{}{
				"ProgesteronePerInjection": 1.0,
				"AutoDeduct":               true,
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// getInventoryDisplayName returns a friendly display name for inventory items
func getInventoryDisplayName(itemType string) string {
	names := map[string]string{
		"progesterone":     "Progesterone",
		"draw_needle":      "Draw Needles",
		"injection_needle": "Injection Needles",
		"syringe":          "Syringes",
		"swab":             "Alcohol Swabs",
		"gauze":            "Gauze Pads",
	}
	if name, ok := names[itemType]; ok {
		return name
	}
	return itemType
}

// getInventoryIcon returns an icon/emoji for inventory items
func getInventoryIcon(itemType string) string {
	icons := map[string]string{
		"progesterone":     "",
		"draw_needle":      "",
		"injection_needle": "",
		"syringe":          "",
		"swab":             "",
		"gauze":            "",
	}
	if icon, ok := icons[itemType]; ok {
		return icon
	}
	return ""
}

// HandleCoursesPage renders the courses page
func HandleCoursesPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Courses"
		accountID := middleware.GetAccountID(r.Context())

		// Get active course
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			activeData := map[string]interface{}{
				"ID":            activeCourse.ID,
				"Name":          activeCourse.Name,
				"StartDate":     activeCourse.StartDate.Format("Jan 2, 2006"),
				"StartDateISO":  activeCourse.StartDate.Format("2006-01-02"),
				"Notes":         "",
			}
			if activeCourse.ExpectedEndDate.Valid {
				activeData["ExpectedEndDate"] = activeCourse.ExpectedEndDate.Time.Format("Jan 2, 2006")
				activeData["ExpectedEndDateISO"] = activeCourse.ExpectedEndDate.Time.Format("2006-01-02")
			}
			if activeCourse.Notes.Valid {
				activeData["Notes"] = activeCourse.Notes.String
			}
			data["ActiveCourse"] = activeData
		}

		// Get past courses
		courses, err := courseRepo.List(accountID)
		if err == nil {
			pastCourses := []map[string]interface{}{}
			for _, course := range courses {
				if !course.IsActive {
					pastData := map[string]interface{}{
						"ID":           course.ID,
						"Name":         course.Name,
						"StartDate":    course.StartDate.Format("Jan 2, 2006"),
						"StartDateISO": course.StartDate.Format("2006-01-02"),
					}
					if course.ActualEndDate.Valid {
						pastData["ActualEndDate"] = course.ActualEndDate.Time.Format("Jan 2, 2006")
						pastData["ActualEndDateISO"] = course.ActualEndDate.Time.Format("2006-01-02")
					}
					if course.ExpectedEndDate.Valid {
						pastData["ExpectedEndDate"] = course.ExpectedEndDate.Time.Format("Jan 2, 2006")
						pastData["ExpectedEndDateISO"] = course.ExpectedEndDate.Time.Format("2006-01-02")
					}
					if course.Notes.Valid {
						pastData["Notes"] = course.Notes.String
					}
					pastCourses = append(pastCourses, pastData)
				}
			}
			if len(pastCourses) > 0 {
				data["PastCourses"] = pastCourses
			}
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "courses.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleCalendarPage renders the calendar page
func HandleCalendarPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Calendar - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "calendar.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleReportsPage renders the reports page
func HandleReportsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Reports - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "reports.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSettingsPage renders the settings page
func HandleSettingsPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Settings"

		userID := middleware.GetUserID(r.Context())

		// Get user-specific settings
		settings := map[string]interface{}{
			"Theme":                "auto",
			"Timezone":             "America/New_York",
			"DateFormat":           "MM/DD/YYYY",
			"TimeFormat":           "12h",
			"AdvancedMode":         false,
			"EnableNotifications":  false,
			"InjectionReminders":   false,
			"ReminderTime":         "19:00",
			"LowStockAlerts":       true,
		}

		// Query user settings
		rows, err := db.Query(`SELECT key, value FROM settings WHERE key LIKE ? OR key NOT LIKE 'user_%'`,
			fmt.Sprintf("user_%%_%d", userID))
		if err == nil {
			defer rows.Close()
			for rows.Next() {
				var key, value string
				if err := rows.Scan(&key, &value); err == nil {
					switch {
					case strings.HasPrefix(key, fmt.Sprintf("user_theme_%d", userID)):
						settings["Theme"] = value
					case strings.HasPrefix(key, fmt.Sprintf("user_timezone_%d", userID)):
						settings["Timezone"] = value
					case strings.HasPrefix(key, fmt.Sprintf("user_date_format_%d", userID)):
						settings["DateFormat"] = value
					case strings.HasPrefix(key, fmt.Sprintf("user_time_format_%d", userID)):
						settings["TimeFormat"] = value
					case key == "advanced_mode_enabled":
						settings["AdvancedMode"] = (value == "true")
					case strings.HasPrefix(key, fmt.Sprintf("user_enable_notifications_%d", userID)):
						settings["EnableNotifications"] = (value == "true")
					case key == "injection_reminders":
						settings["InjectionReminders"] = (value == "true")
					case key == "reminder_time":
						settings["ReminderTime"] = value
					case key == "low_stock_alerts":
						settings["LowStockAlerts"] = (value == "true")
					}
				}
			}
		}

		data["Settings"] = settings
		data["User"] = map[string]interface{}{
			"Username": "User", // TODO: Get actual username
			"Email":    "",
		}
		data["DatabaseSize"] = "N/A"
		data["LastBackup"] = "N/A"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "settings.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewCoursePage redirects to courses page with action parameter to open modal
func HandleNewCoursePage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/courses?action=new", http.StatusSeeOther)
	}
}

// HandleLogSymptomPage renders the log symptom page
func HandleLogSymptomPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to symptoms page
		http.Redirect(w, r, "/symptoms?action=new", http.StatusSeeOther)
	}
}

// HandleEditSymptomPage renders the edit symptom page
func HandleEditSymptomPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Edit Symptom - Injection Tracker"
		accountID := middleware.GetAccountID(r.Context())

		// Get symptom ID from URL
		idStr := chi.URLParam(r, "id")
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err != nil {
			http.Error(w, "Invalid symptom log ID", http.StatusBadRequest)
			return
		}

		// Get symptom log
		symptomRepo := repository.NewSymptomRepository(db)
		symptom, err := symptomRepo.GetByID(id)
		if err != nil {
			http.Error(w, "Symptom log not found", http.StatusNotFound)
			return
		}

		// Get active course for the template
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		data["Symptom"] = symptom

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptom_edit.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleSymptomsHistoryPage renders the symptoms history page
func HandleSymptomsHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Symptom History - Injection Tracker"
		accountID := middleware.GetAccountID(r.Context())

		// Get active course for consistency with other pages
		courseRepo := repository.NewCourseRepository(db)
		activeCourse, err := courseRepo.GetActiveCourse(accountID)
		if err == nil && activeCourse != nil {
			data["ActiveCourse"] = activeCourse
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "symptoms-history.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleNewMedicationPage redirects to medications page with modal
func HandleNewMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// HandleLogMedicationPage renders the log medication page
func HandleLogMedicationPage(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// For now, redirect to medications page
		http.Redirect(w, r, "/medications?action=new", http.StatusSeeOther)
	}
}

// formatTimeAgoWeb returns a human-readable time ago string
func formatTimeAgoWeb(t time.Time) string {
	duration := time.Since(t)
	if duration.Hours() < 1 {
		minutes := int(duration.Minutes())
		if minutes == 1 {
			return "1 minute ago"
		}
		return fmt.Sprintf("%d minutes ago", minutes)
	} else if duration.Hours() < 24 {
		hours := int(duration.Hours())
		if hours == 1 {
			return "1 hour ago"
		}
		return fmt.Sprintf("%d hours ago", hours)
	} else {
		days := int(duration.Hours() / 24)
		if days == 1 {
			return "1 day ago"
		}
		return fmt.Sprintf("%d days ago", days)
	}
}

// HandleGetRecentActivity returns recent activity HTML for dashboard
func HandleGetRecentActivity(db *database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID := middleware.GetUserID(r.Context())
		userTimezone := GetUserTimezone(db, userID)

		// Get recent activity using UNION to combine and sort by timestamp
		rows, err := db.Query(`
			SELECT 'injection' as type, timestamp, side as detail1, CAST(pain_level AS TEXT) as detail2, notes, id
			FROM injections
			UNION ALL
			SELECT 'symptom' as type, timestamp, pain_location as detail1, CAST(pain_level AS TEXT) as detail2, notes, id
			FROM symptom_logs
			UNION ALL
			SELECT 'medication' as type, timestamp,
				(SELECT name FROM medications WHERE id = medication_logs.medication_id) as detail1,
				CASE WHEN taken = 1 THEN 'taken' ELSE 'missed' END as detail2,
				notes, medication_logs.id
			FROM medication_logs
			ORDER BY timestamp DESC
			LIMIT 10
		`)

		if err != nil {
			w.Header().Set("Content-Type", "text/html")
			w.Write([]byte(`<p>Error loading activity</p>`))
			return
		}
		defer rows.Close()

		activities := []map[string]interface{}{}
		for rows.Next() {
			var actType, detail1, detail2 string
			var timestamp time.Time
			var notes sql.NullString
			var id int64

			if err := rows.Scan(&actType, &timestamp, &detail1, &detail2, &notes, &id); err == nil {
				// Convert timestamp to user's timezone
				convertedTime := ConvertToUserTZ(timestamp, userTimezone)
				activities = append(activities, map[string]interface{}{
					"Type":      actType,
					"Detail1":   detail1,
					"Detail2":   detail2,
					"Notes":     notes.String,
					"Timestamp": convertedTime,
					"TimeAgo":   formatTimeAgoWeb(convertedTime),
					"ID":        id,
				})
			}
		}

		if len(activities) == 0 {
			w.Header().Set("Content-Type", "text/html")
			w.Write([]byte(`
				<div style="text-align: center; padding: 2rem; color: var(--pico-muted-color);">
					<p>No recent activity yet.</p>
					<small>Start by logging your first injection, symptom, or medication!</small>
				</div>
			`))
			return
		}

		// Render recent activity with better styling
		w.Header().Set("Content-Type", "text/html")
		html := `<div style="display: flex; flex-direction: column; gap: 0.5rem;">`

		for _, activity := range activities {
			html += `<article style="margin: 0; padding: 0.75rem;">`

			switch activity["Type"].(string) {
			case "injection":
				side := activity["Detail1"].(string)
				painLevel := activity["Detail2"].(string)
				html += fmt.Sprintf(`<div style="display: flex; justify-content: space-between; align-items: start;">
					<div>
						<strong>Injection (%s)</strong>`, strings.Title(side))
				if painLevel != "" && painLevel != "0" {
					html += fmt.Sprintf(` <small>Pain: %s/10</small>`, painLevel)
				}
				html += fmt.Sprintf(`<br><small style="color: var(--pico-muted-color);">%s</small>`, activity["TimeAgo"])
			case "symptom":
				location := activity["Detail1"].(string)
				painLevel := activity["Detail2"].(string)
				html += `<div style="display: flex; justify-content: space-between; align-items: start;">
					<div>
						<strong>Symptom Logged</strong>`
				if location != "" {
					html += fmt.Sprintf(` <small>%s</small>`, strings.ReplaceAll(location, "_", " "))
				}
				if painLevel != "" && painLevel != "0" {
					html += fmt.Sprintf(` <small>Pain: %s/10</small>`, painLevel)
				}
				html += fmt.Sprintf(`<br><small style="color: var(--pico-muted-color);">%s</small>`, activity["TimeAgo"])
			case "medication":
				medName := activity["Detail1"].(string)
				status := activity["Detail2"].(string)
				statusColor := "var(--pico-ins-color)"
				if status == "missed" {
					statusColor = "var(--pico-del-color)"
				}
				html += fmt.Sprintf(`<div style="display: flex; justify-content: space-between; align-items: start;">
					<div>
						<strong>%s</strong> <small style="color: %s;">%s</small>
						<br><small style="color: var(--pico-muted-color);">%s</small>`,
					medName, statusColor, strings.Title(status), activity["TimeAgo"])
			}

			if notes, ok := activity["Notes"].(string); ok && notes != "" {
				if len(notes) > 60 {
					notes = notes[:60] + "..."
				}
				html += fmt.Sprintf(`<br><small>%s</small>`, notes)
			}

			html += `</div></div></article>`
		}

		html += `</div>`
		w.Write([]byte(html))
	}
}

// HandleActivityPage renders the full activity history page
func HandleActivityPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Activity History - Injection Tracker"

		// Get user's timezone preference
		userID := middleware.GetUserID(r.Context())
		userTimezone := GetUserTimezone(db, userID)

		// Get all activity using UNION to combine and sort by timestamp
		rows, err := db.Query(`
			SELECT 'injection' as type, timestamp, side as detail1, CAST(pain_level AS TEXT) as detail2, notes, id
			FROM injections
			UNION ALL
			SELECT 'symptom' as type, timestamp, pain_location as detail1, CAST(pain_level AS TEXT) as detail2, notes, id
			FROM symptom_logs
			UNION ALL
			SELECT 'medication' as type, timestamp,
				(SELECT name FROM medications WHERE id = medication_logs.medication_id) as detail1,
				CASE WHEN taken = 1 THEN 'taken' ELSE 'missed' END as detail2,
				notes, medication_logs.id
			FROM medication_logs
			ORDER BY timestamp DESC
		`)

		if err != nil {
			http.Error(w, "Failed to load activity", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		activities := []map[string]interface{}{}
		for rows.Next() {
			var actType, detail1, detail2 string
			var timestamp time.Time
			var notes sql.NullString
			var id int64

			if err := rows.Scan(&actType, &timestamp, &detail1, &detail2, &notes, &id); err == nil {
				// Convert timestamp to user's timezone
				convertedTime := ConvertToUserTZ(timestamp, userTimezone)
				formattedDateTime := FormatDateTimeForUser(db, userID, timestamp)
				activities = append(activities, map[string]interface{}{
					"Type":      actType,
					"Detail1":   detail1,
					"Detail2":   detail2,
					"Notes":     notes.String,
					"Timestamp": convertedTime,
					"TimeAgo":   formatTimeAgoWeb(convertedTime),
					"FormattedDate": formattedDateTime,
					"ID":        id,
				})
			}
		}

		data["Activities"] = activities

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "activity.html", data); err != nil {
			http.Error(w, "Failed to render template: "+err.Error(), http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryHistoryPage renders the full inventory history page
func HandleInventoryHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		data["Title"] = "Inventory History - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory_history.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}

// HandleInventoryItemHistoryPage renders the inventory history for a specific item type
func HandleInventoryItemHistoryPage(db *database.DB, csrf *middleware.CSRFProtection) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data := getBasePageData(r, csrf)
		itemType := chi.URLParam(r, "itemType")
		
		// Display names for item types
		displayNames := map[string]string{
			"progesterone":      "Progesterone",
			"draw_needle":       "Draw Needles",
			"injection_needle":  "Injection Needles",
			"syringe":          "Syringes",
			"swab":             "Alcohol Swabs",
			"gauze":            "Gauze Pads",
		}
		
		displayName, ok := displayNames[itemType]
		if !ok {
			http.Error(w, "Invalid item type", http.StatusBadRequest)
			return
		}
		
		data["ItemType"] = itemType
		data["DisplayName"] = displayName
		data["Title"] = displayName + " History - Injection Tracker"

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := web.Render(w, "inventory_item_history.html", data); err != nil {
			http.Error(w, "Failed to render template", http.StatusInternalServerError)
			return
		}
	}
}
